namespace _00.Demo
{
    public class Program
    {
        static void Main(string[] args)
        {

            /*
            SOLID Principles
            S - индивидуална отговорност (Single Responsibility Principle)
            O - отворен/затворен (Open/Closed Principle)
            L - Всички наследници трябва да могат да заместват базовите си класове (Liskov Substitution Principle)
            I - разделяне на интерфейси  (Interface Segregation Principle)
            D - всички зависимусти на койти мойте класове разчитат да бъдат лесно подменяеми (Dependency Inversion Principle)


            Strong Cohesion - фокус в една посока и тяхната
            функционалност да бъде съсредоточена в една област

            Loose Coupling - ниска степен на зависимост между
            отделните компоненти на системата(Spaghetti Code)

           1. Да използваме интерфейси и абстрактни класове
              за да намалим зависимостите между отделните компоненти на системата.
           2. Винаги да се замисляме дали нашия клас не върши твърде много неща
              и дали не трябва да го разделим на по-малки класове с по-конкретна отговорност.
           3. Да се стремим към висока степен на кохезия.
              Това означава, че всички методи и свойства на един клас трябва да бъдат свързани с неговата основна отговорност.
           4. Да се стремим към ниска степен на свързаност между отделните компоненти на системата.
              Това означава, че промените в един клас трябва да имат минимално въздействие върху другите класове.
         ===================================================================================================================

            Open/Closed Principle

            1. Класовете трябва да бъдат отворени за разширение, но затворени за модификация.
            2. Това означава, че трябва да можем да добавяме нова функционалност към нашите класове
               без да променяме съществуващия код.
            3. Това може да се постигне чрез използване на абстракции, интерфейси и наследяване.
            4. Пример: Имаме клас Shape с метод Draw(). Ако искаме да добавим нова форма,
               като Circle или Rectangle, ние създаваме нови класове, които наследяват Shape
               и имплементират своята версия на Draw(), вместо да променяме съществуващия клас Shape.
            5. По този начин, ако имаме колекция от Shape обекти, можем да ги обработваме полиморфно
                без да се налага да променяме кода, който ги използва.
            6. Това води до по-лесна поддръжка и разширяемост на кода.
            7. Важно е да се отбележи, че Open/Closed Principle не означава, че никога не трябва да променяме съществуващия код.
               Понякога е необходимо да направим промени, но трябва да се стремим да минимизираме тези промени
               и да използваме принципа, когато е възможно.

            Има два подхода за прилагане на Open/Closed Principle:

            1. Strategy Pattern - функционалноста идва през Interface.
              Създаваме интерфейс с определен метод и различни класове, които го имплементират.
              По този начин можем да добавяме нови стратегии без да променяме съществуващия код.

            2. Template Method Pattern - с абстрактен клас, който дефинира скелета на алгоритъма.
              Наследниците могат да променят определени стъпки от алгоритъма, без да променят неговата структура.

            =========================================================================================================================

            Liskov Substitution Principle

            1. Наследниците трябва да могат да заместват базовите си класове.
            2. Наследника не трябва да променя функционалноста на базовия клас.
            3. Наследниците само добавят нова функционалност, без да променят съществуващата.
            4. Type Checking - избягваме проверки от типа "if (obj is DerivedClass)".
            5. Override Methods - казва "I am not implemented" ако не е спазен принципа.


            =========================================================================================================================

            Interface Segregation Principle

            1. Клиентите не трябва да бъдат принуждавани да зависят от интерфейси, които не използват.
            2. По-добре е да имаме много специфични интерфейси, отколкото един общ интерфейс.
            3. Това води до по-гъвкав и лесен за поддръжка код.
            4. Пример: Вместо да имаме един интерфейс IWorker с методи Work() и Sleep(),
               можем да създадем два отделни интерфейса IWorkable и ISleepable.

               public interface IWorker
               {
               void Work();
               void Sleep();
               }

               public class Robot : IWorker
               {
               void Work()  { … }
               void Sleep() { throw new NotImplementedException() } // Нарушение на ISP
               }
            ==========================  ================================================================================================

            Dependency Inversion Principle

            1. Всички зависимости на които разчитат моите класове трябва да бъдат лесно подменяеми.
            2. Високо ниво на модула не трябва да зависи от ниско ниво на модула.
               И двата трябва да зависят от абстракции (интерфейси или абстрактни класове).
            3. Абстракциите не трябва да зависят от детайли. Детайлите трябва да зависят от абстракции.
            4. Пример: Имаме клас UserService, който зависи от клас UserRepository.
               Вместо да създаваме директна зависимост, можем да използваме интерфейс IUserRepository,
               който UserRepository имплементира. По този начин можем лесно да подменяме UserRepository
               с друг клас, който също имплементира IUserRepository, без да променяме UserService.
            5. Това води до по-гъвкав и лесен за поддръжка код.
            6. Чрез използване на Dependency Injection (DI) можем да управляваме зависимостите
               между класовете по-лесно и ефективно.
            7. Това също улеснява тестването на кода, тъй като можем лесно да подменяме реалните зависимости
               с mock обекти по време на тестване.
            8. Важно е да се отбележи, че прилагането на Dependency Inversion Principle
               изисква внимателно планиране и дизайн на архитектурата на приложението.
            9. 99 % в случаите да се използва конструкто.

           */



        }
    }
}
